\# SQL JOIN Queries



This script (`joins\_queries.sql`) provides examples of different types of SQL JOIN clauses to retrieve data from a relational database, such as one that might power a property rental application like Airbnb.



\## Assumed Database Schema



The queries are based on a hypothetical schema consisting of the following tables:



\-   \*\*`users`\*\*: Stores user information.

&nbsp;   -   `user\_id` (Primary Key)

&nbsp;   -   `username`

&nbsp;   -   `email`

\-   \*\*`properties`\*\*: Stores property listing details.

&nbsp;   -   `property\_id` (Primary Key)

&nbsp;   -   `title`

&nbsp;   -   `location`

\-   \*\*`bookings`\*\*: Stores booking records, linking users to properties.

&nbsp;   -   `booking\_id` (Primary Key)

&nbsp;   -   `user\_id` (Foreign Key to `users`)

&nbsp;   -   `property\_id` (Foreign Key to `properties`)

\-   \*\*`reviews`\*\*: Stores reviews for properties.

&nbsp;   -   `review\_id` (Primary Key)

&nbsp;   -   `property\_id` (Foreign Key to `properties`)

&nbsp;   -   `user\_id` (Foreign Key to `users`)

&nbsp;   -   `rating`

&nbsp;   -   `comment`



\## Queries Included



\### 1. INNER JOIN



\-   \*\*Purpose\*\*: To retrieve all bookings along with the details of the user who made each booking.

\-   \*\*Result\*\*: This query will only return rows where a booking has a corresponding user. Bookings without a user or users without a booking will be excluded.



\### 2. LEFT JOIN



\-   \*\*Purpose\*\*: To retrieve all properties and any reviews they may have.

\-   \*\*Result\*\*: This query lists every property from the `properties` table. If a property has reviews, the review details will be included. If a property has no reviews, the review-related columns will be `NULL`.



\### 3. FULL OUTER JOIN



\-   \*\*Purpose\*\*: To retrieve all users and all bookings, showing the relationship between them.

\-   \*\*Result\*\*: This query combines all records from both the `users` and `bookings` tables. It will show:

&nbsp;   -   Users who have made bookings.

&nbsp;   -   Users who have not made any bookings.

&nbsp;   -   Bookings that are not associated with any user (e.g., orphaned records).



\*\*Note on Compatibility\*\*: The `FULL OUTER JOIN` is standard in SQL databases like PostgreSQL and SQL Server but is not available in MySQL.


# SQL Subqueries

This script (`subqueries.sql`) provides examples of both correlated and non-correlated SQL subqueries. A subquery, or inner query, is a query nested inside another SQL query.

## Assumed Database Schema

The queries are based on a hypothetical schema for a property rental application:

-   **`users`**: Stores user information (`user_id`, `username`).
-   **`properties`**: Stores property details (`property_id`, `title`).
-   **`bookings`**: Records bookings, linking users to properties (`booking_id`, `user_id`).
-   **`reviews`**: Stores property reviews (`review_id`, `property_id`, `rating`).

## Queries Included

### 1. Non-Correlated Subquery

-   **Purpose**: To find all properties with an average rating greater than 4.0.
-   **How it works**: A non-correlated subquery is an independent query whose output is used by the outer query.
    1.  The inner query first calculates the average rating for each property and returns a list of `property_id`s that have an average rating above 4.0.
    2.  The outer query then selects all details from the `properties` table where the `property_id` is in the list generated by the inner query.

### 2. Correlated Subquery

-   **Purpose**: To find all users who have made more than 3 bookings.
-   **How it works**: A correlated subquery depends on the outer query for its values. It is executed once for each row evaluated by the outer query.
    1.  The outer query iterates through each user in the `users` table.
    2.  For each user, the inner query is executed. It counts the total number of bookings in the `bookings` table that belong to that specific user (`WHERE b.user_id = u.user_id`).
    3.  The outer query's `WHERE` clause then checks if this count is greater than 3. If it is, the user is included in the final result set.

# SQL Aggregation and Window Functions

This document explains the SQL queries in the `aggregations_and_windows.sql` script. These queries demonstrate how to use aggregation and window functions to analyze data from a hypothetical property rental application.

## Assumed Database Schema

The queries assume a simple relational database schema with the following tables:

-   **`users`**: Stores user information.
    -   `user_id` (Primary Key)
    -   `username`
-   **`properties`**: Stores details about each property listing.
    -   `property_id` (Primary Key)
    -   `title`
-   **`bookings`**: Records each booking, linking a user to a property.
    -   `booking_id` (Primary Key)
    -   `user_id` (Foreign Key to `users`)
    -   `property_id` (Foreign Key to `properties`)
    -   `booking_date`

## Queries Explained

### 1. Total Bookings per User (Aggregation)

This query calculates the total number of bookings made by each user.

-   **`COUNT(b.booking_id)`**: This aggregate function counts the number of bookings.
-   **`GROUP BY u.user_id, u.username`**: This clause groups the rows so that `COUNT` works on a per-user basis. All bookings for a single user are grouped together, and the count is calculated for that group.
-   **`JOIN`**: An `INNER JOIN` is used to link the `users` and `bookings` tables to retrieve the username for each user ID.

### 2. Ranking Properties by Bookings (Window Functions)

This query ranks properties based on how many bookings they have received. It uses a Common Table Expression (CTE) and several window functions to achieve this.

-   **`WITH PropertyBookingCounts AS (...)`**: The CTE first calculates the total number of bookings for each property, creating a temporary result set named `PropertyBookingCounts`. This simplifies the main query.
-   **`OVER (ORDER BY pbc.booking_count DESC)`**: This is the window function clause. It defines the "window" of rows (in this case, all rows) and the order in which they should be processed to calculate the rank.
-   **`ROW_NUMBER()`**: Assigns a unique, sequential number to each property based on its booking count (e.g., 1, 2, 3, 4). No two rows will have the same row number.
-   **`RANK()`**: Assigns a rank to each property. If two properties have the same number of bookings, they receive the same rank. The next rank is then skipped (e.g., 1, 2, 2, 4).
-   **`DENSE_RANK()`**: Similar to `RANK`, but it does not skip ranks after a tie (e.g., 1, 2, 2, 3). This is useful when you want a continuous ranking.